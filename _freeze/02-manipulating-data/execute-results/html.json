{
  "hash": "4981c4d1d9b2230289a7832a0a4ff926",
  "result": {
    "engine": "knitr",
    "markdown": "# Reading & Manipulating Data {#sec-chap02}\n\n\n\n\n\n## Table of content for chapter 02\n\n::: {#obj-chap02}\n::: my-objectives\n::: my-objectives-header\nChapter section list\n:::\n\n::: my-objectives-container\n-   Data Input\n    -   Accessing data from a package (@sec-chap02-1-1)\n    -   ~~Entering a data frame directly (empty)~~ (@sec-chap02-1-2)\n    -   ~~Reading data from plain-text files (empty)~~ (@sec-chap02-1-3)\n    -   ~~File and Paths (empty)~~ {@sec-chap02-1-4}\n    -   ~~Exporting or saving a data frame to a file (empty)~~ (@sec-chap02-1-5)\n    -   Reading and writing other file formats (@sec-chap02-1-6)\n-   Other Approaches to Reading and Managing Data Sets in R (@sec-chap02-2)\n-   Working with data frames (@sec-chap02-3)\n    - ~~How the R interpreter finds objects (empty)~~ (@sec-chap02-3-1)\n    - Missing data (@sec-chap02-3-2)\n    - Modifying and transforming data (@sec-chap02-3-3)\n    - ~~Binding rows and columns (empty)~~ (@sec-chap02-3-4)\n    - ~~Aggregating data frames (empty)~~ (@sec-chap02-3-5)\n    - ~~Merging data frames (empty)~~ (@sec-chap02-3-6)\n    - ~~Reshaping data (empty)~~ (@sec-chap02-3-7)\n- ~~Working with matrices, arrays, and lists (empty)~~ (@sec-chap02-4)\n- ~~Dates and times (empty)~~ (@sec-chap02-5)\n- ~~Character data (empty)~~ (@sec-chap02-6)\n- ~~Large datasets in R (empty)~~ (@sec-chap02-7)\n:::\n:::\n:::\n\n## Data Input\n\n### Accessing data from a package {#sec-chap02-1-1}\n\nThere are two ways to access data from a package:\n\n-   Loading the package with `base::library(<packageName>)`\n-   Accessing with\n    `utils::data(\"<dataName>\", package = \"<packageName>\")` without first\n    loading the package\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-chap02-load-data-display-extract}\n: Load data and display a data extract with different methods\n:::\n:::\n\n::: my-r-code-container\n::: {#lst-chap02-load-data-display-extract}\n\n::: {.cell}\n\n```{.r .cell-code}\nutils::data(\"Davis\", package = \"carData\")\n\nglue::glue(\"---------------------------------------------------------------------\")\nglue::glue(\"utils::str: Compactly Display the Structure of an Arbitrary R Object\")\nglue::glue(\"---------------------------------------------------------------------\")\nutils::str(Davis)\n\nglue::glue(\" \")\nglue::glue(\"---------------------------------------------------------------------\")\nglue::glue(\"car::brief: Print Abbreviated Ouput\")\nglue::glue(\"---------------------------------------------------------------------\")\ncar::brief(Davis)\n\nglue::glue(\" \")\nglue::glue(\"---------------------------------------------------------------------\")\nglue::glue(\"my_glance_data: my own function\")\nglue::glue(\"---------------------------------------------------------------------\")\nmy_glance_data(Davis)\n\nglue::glue(\" \")\nglue::glue(\"---------------------------------------------------------------------\")\nglue::glue(\"dplyr::glimpse: Get a glimpse of your data\")\nglue::glue(\"---------------------------------------------------------------------\")\ndplyr::glimpse(Davis)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> ---------------------------------------------------------------------\n#> utils::str: Compactly Display the Structure of an Arbitrary R Object\n#> ---------------------------------------------------------------------\n#> 'data.frame':\t200 obs. of  5 variables:\n#>  $ sex   : Factor w/ 2 levels \"F\",\"M\": 2 1 1 2 1 2 2 2 2 2 ...\n#>  $ weight: int  77 58 53 68 59 76 76 69 71 65 ...\n#>  $ height: int  182 161 161 177 157 170 167 186 178 171 ...\n#>  $ repwt : int  77 51 54 70 59 76 77 73 71 64 ...\n#>  $ repht : int  180 159 158 175 155 165 165 180 175 170 ...\n#>  \n#> ---------------------------------------------------------------------\n#> car::brief: Print Abbreviated Ouput\n#> ---------------------------------------------------------------------\n#> 200 x 5 data.frame (195 rows omitted)\n#>     sex weight height repwt repht\n#>     [f]    [i]    [i]   [i]   [i]\n#> 1   M       77    182    77   180\n#> 2   F       58    161    51   159\n#> 3   F       53    161    54   158\n#> . . .                                 \n#> 199 M       90    181    91   178\n#> 200 M       79    177    81   178\n#>  \n#> ---------------------------------------------------------------------\n#> my_glance_data: my own function\n#> ---------------------------------------------------------------------\n#>          obs sex weight height repwt repht\n#> 1          1   M     77    182    77   180\n#> 49        49   F     54    174    56   173\n#> 65        65   M     97    189    98   185\n#> 74        74   F     56    163    57   159\n#> 122      122   M     69    167    73   165\n#> 128      128   F     45    157    45   153\n#> 146      146   F     55    160    55   155\n#> 153      153   F     47    150    45   152\n#> 200...9  200   M     79    177    81   178\n#> 200...10 200   M     79    177    81   178\n#>  \n#> ---------------------------------------------------------------------\n#> dplyr::glimpse: Get a glimpse of your data\n#> ---------------------------------------------------------------------\n#> Rows: 200\n#> Columns: 5\n#> $ sex    <fct> M, F, F, M, F, M, M, M, M, M, M, F, F, F, F, F, M, F, M, F, M, …\n#> $ weight <int> 77, 58, 53, 68, 59, 76, 76, 69, 71, 65, 70, 166, 51, 64, 52, 65…\n#> $ height <int> 182, 161, 161, 177, 157, 170, 167, 186, 178, 171, 175, 57, 161,…\n#> $ repwt  <int> 77, 51, 54, 70, 59, 76, 77, 73, 71, 64, 75, 56, 52, 64, 57, 66,…\n#> $ repht  <int> 180, 159, 158, 175, 155, 165, 165, 180, 175, 170, 174, 163, 158…\n```\n\n\n:::\n:::\n\n\nAccessing data from a package and using different methods for displaying\na data extract\n:::\n\n------------------------------------------------------------------------\n\nThere is a problem with the data files from the {**carData**} package:\nThe files have relevant information in the row names. But row names are\nnot part of the data frame. This can be easily seen by applying\nfunctions like `utils::str()` or `dplyr::glimpse()`.\n\nThis is not a great deal here with the Davis data set as it only\ncontains the index of the row numbers. But it is an annoying \"feature\"\nwhen it has important information that belong into a column of the data\nframe. We have already met such a data frame with `Duncan` in\n@lst-chap01-get-duncan-data.\n\nSee @sec-chap02-2 for a more detailed treatment and why I need row names\nusing the {**car**} package.\n:::\n:::\n\nSome packages require that you call the `utils::data()` function to use\ndata frames in the package, even when the package is loaded. Other\npackages, like {**carData**}, use R’s lazy data mechanism to provide\ndirect access to data frames when the package is loaded. On a package’s\nhelp page, accessed, for example, by `help(package=\"carData\")`, click on\nthe link for the package `DESCRIPTION file`. Data frames are\nautomatically available if the line `LazyData: yes` appears in the\npackage description.\n\n### Entering a data frame directly (empty) {#sec-chap02-1-2}\n\n### Reading data from plain-text files (empty) {#sec-chap02-1-3}\n\n### File and Paths (empty) {#sec-chap02-1-4}\n\n### Exporting or saving a data frame to a file (empty) {#sec-chap02-1-5}\n\n### Reading and writing other file formats {#sec-chap02-1-6}\n\nThe {**car**} package includes a function named `car::Import()` that\ncalls the `import()` function in {**rio**} but uses different defaults\nand arguments, more closely matching the specifications that the authors\nexpect users of the {**car**} package to prefer. In particular:\n\n1.  **Row names**: The `rio::import()` function does not support row\n    names, while `car::Import()` allows you to convert a column in the\n    input data file into row names. By default, `car::Import()` assumes\n    that the first character column with unique values in the input data\n    set represents row names. If you do not want `car::Import()` to use\n    row names, set the argument `row.names = FALSE`.\n2.  **Conversion to factors**: The `rio::import()` function does not\n    support automatic conversion of character data to factors, while\n    `car::Import()` by default converts character variables to factors.\n    To suppress converting character variables to factors, add the\n    argument `stringsAsFactors = FALSE`.\n\nThe `car::Export()` function similarly writes data files in various\nformats. `car::Export()` is identical in use to the `rio::export()` but\n`car::Export()` has an additional argument, `keep.row.names`: Setting\n`keep.row.names = TRUE` adds the row names in a data frame as an\nadditional initial column of the output data set, with the column name\n`id`.\n\n::: {#wrn-prefer-tidyverse .callout-warning}\n##### My preferences are {**readr**}, {**haven**} and {**foreign**}\n\nAs I am trying to stick with the {**tidyverse**} approach and not to use\ndifferent packages for the same task, I will neither use the {**rio**}\nnor the {**car**} file import/export commands.\n\nMy preferences are {**readr**}, {**haven**} and {**foreign**} (in that\norder).\n:::\n\n## Other approaches to reading and managing data sets in R {#sec-chap02-2}\n\nFox & Weisberg are not using the tidyverse file commands for two\nreasons:\n\n1.  {**tidyverse**} packages are actively antagonistic to the use of row\n    names.\n2.  {**tidyverse**} packages does not automatically convert character\n    variables to factors.\n\nBoth arguments for the critics are not convinging for me:\n\nad 1) **Why using row names for indiviual labelling?**\n\n> Avoiding\trow\tnames\tmay\tbe\ta reasonable\tstrategy\tfor\thuge\tdata\tsets\twhere\tthe\tcases\tdon’t\thave\tindividual identities\tbeyond\ttheir\trow\tnumbers,\tbut\tautomatic\tlabeling\tof\tindividual cases\tby\ttheir\trow\tnames\tcan\tbe\tvery\tuseful\tin\tregression\tdiagnostics\tand for\tother\tmethods\tthat\tidentify\tunusual\tor\tinfluential\tcases.\n\nLabelling individual cases are important information and should be incorparated into the data file as a column. The strategy to use these individual names could be fulfilled referencing this columns or applying a default value (for instance the first column in the data set).\n\nAs things stand I need to use row names to use the advanced features of the {**car**} package. This excludes the use of tibbles: Whenever you add row names to a tibble it will loose it special features because it will be converted automatically to a data frame.\n\n::: {.callout-important #imp-row-names-tools}\n##### Working with row names\n\nThere are several tools for working with row names (see: [Tools for working with row names](https://tibble.tidyverse.org/reference/rownames.html)) which will become important when applying the {**car**} package and trying still to be following the tidyverse approach as well as in any way possible:\n\n- `tibble::has_rownames(<dataFrame>)`\n- `remove_rownames(<dataFrame>)`\n- `rownames_to_column(<dataFrame>, var = \"<rowNameColumn>\")`\n- `rowid_to_column(<dataFrame>, var = \"<rowNameId>\")`\n- `column_to_rownames(.data, var = \"<rowNameColumn>\")`\n:::\n\nad 2) **Why using `stringAsFactor = TRUE` as default?**\n\nEven R has with version 4.0.0 the default changed to `stringsAsFactors = FALSE`, and \"hence by default [R] no longer convert strings to factors in calls to  `data.frame()` and `read.table()`\" ([R 4.0.0 is released](https://stat.ethz.ch/pipermail/r-announce/2020/000653.html)).\n\nBesides it is easy to change this default. It is therefore no big deal in my opinion that justifies to decline the advantages of the {**tidyverse**} packages.\n\n:::::{.my-remark}\n:::{.my-remark-header}\n:::::: {#rem-chap02-car-tidyverse}\n: My strategy to harmonize {**car**} with {**tidyverse**}\n::::::\n:::\n::::{.my-remark-container}\nAs far as I understand the {**car**} packages provides many important enhancement for the regression analysis that are not included in base R or other packages including {**tidyverse**}. But I trust the future development of the {**tidyverse**} approache more than the professors Fox and Weisberg, who both are already retired (professor emeritus).\n\nSo what I am trying with the book:\n\n1. First of all to learn the regression tools in {**car**} for an advanced regression analysis.\n2. To look around if these tools could be incorporated in the {**tidyverse**} approach. Here I am thinking at the moment of two ways:\n    a) Are there packages following the {**tidyverse**} approach that already implement these advanced regression analysis tools? I am thinking here of the huge list of [ggplot2 extensions](https://exts.ggplot2.tidyverse.org/). Currently (2024-05-19) there are 133 registered extensions available to explore!\n    b) Is it possible to code the desired feature myself? At the moment I am not thinking of developing a new package. Maybe it is possible to add the feature with 2-3 lines of code into a seuqence of R commands? An example that inspired me is the formula by D.\tFreedman and Diaconis [-@freedman1981a] that could be added in calls to `ggplot2::geom_histogram()`.\n::::\n:::::\n\n## Working with data frames {#sec-chap02-3}\n\n### How the R interpreter finds objects (empty) {#sec-chap02-3-1}\n\n### Missing data {#sec-chap02-3-2}\n\n:::::{.my-resource}\n:::{.my-resource-header}\n:::::: {#lem-missing-data}\n: Packages for working with missing data\n::::::\n:::\n::::{.my-resource-container}\n- Amelia [@Amelia]\n- ggmice [@ggmice]\n- mi [@mi]\t\n- mice [@mice]\n- naniar [@naniar]\n- norm [@norm]\n\n***\n- See also the [CRAN task view about Missing Data](https://cran.r-project.org/view=MissingData)Flexible \n- [R-miss-tastic](https://rmisstastic.netlify.app/): A resource website on missing values - Methods and references for managing missing data\n- [Multiple Imputation of Missing Data](https://www.john-fox.ca/Companion/appendices/Appendix-Multiple-Imputation.pdf): An Appendix to An R Companion to Applied Regression [@fox2018b]\n- Flexible Imputation of Missing Data Imputation of Missing Data [@buuren2018]. There is also an  [online-version](https://stefvanbuuren.name/fimd/) [@buuren2018a].\n- [Welcome to amices](https://amices.org/): A place for people interested in solving missing data problems.\n- [Amelias II](https://gking.harvard.edu/amelia): Amelia II: A Program for Missing Data.\n- Visualization and Imputation of Missing Values: With Applications in R [@templ2023]\n\n***\n\n\n::: {.cell}\n\n```{.r .cell-code}\npkgs_dl(c(\"Amelia\", \"ggmice\", \"mi\", \"mice\", \"naniar\", \"norm\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 6 × 4\n#>   package average from       to        \n#>   <chr>     <dbl> <date>     <date>    \n#> 1 mice       1819 2024-05-12 2024-05-18\n#> 2 mi          877 2024-05-12 2024-05-18\n#> 3 naniar      585 2024-05-12 2024-05-18\n#> 4 norm        525 2024-05-12 2024-05-18\n#> 5 Amelia      323 2024-05-12 2024-05-18\n#> 6 ggmice       19 2024-05-12 2024-05-18\n```\n\n\n:::\n:::\n\n\n***\nThe top package of my package selection is {**mice**}. It also has the most extensive documentation.\n\nAn interesting choice --- not mentioned in the {**car**} companion --- is {**naniar**}, because it implements NA imputation following the {**tidyverse**} approach.\n\n::::\n:::::\n\nMissing data is a profound statistical issue concerning how best to use available information (\"imputation of missing data\") when missing data are encountered. I will ignore these issues here and postpone for later treatment (learning sessions). Here I will just list general commands to exclude missing data.\n\n\n::: {#bul-ignore-na-commands}\n:::::{.my-bullet-list}\n:::{.my-bullet-list-header}\nCommands to exclude missing data (NA’s)\n:::\n::::{.my-bullet-list-container}\n- `na.rm`: Many R functions that calculate simple statistical summaries, such as `base::mean()`, `stats::var()`, `stats::sd()`, and `stats::quantile()`, have an `na.rm` argument to compute the summaries without NA's. The default value is always `na.rm = FALSE`  so you will get an NA result if you forgot to remove the missing values.\n- `na.action`: Most statistical-modeling functions in R have an `na.action` argument, which controls how missing data are handled: `na.action` is set to a function that takes a data frame as an argument and returns a similar data frame composed entirely of valid data. \n    - `na.omit()`: Default value, which removes all cases with missing data on any variable in the computation. --- You can change the default `na.action` with the `options()` command. For example, `options(na.action=\"na.exclude\")`\n    - `na.exclude()`: Similar to `na.omit()` but saves information about missing cases that are removed. This is the recommended option!\n    - `na.fail()`: Produces an error message.\n- `stats::complete.cases()`: Returns a logical vector indicating which cases are complete, i.e., have no missing values.\n- `tidyr::drop_na()`: Drops rows containing missing values. If no columns are mentioned then the function applies to the whole data set.\n\n***\n\nDon't forget that the proper way to test for missing values is `base::is.na()`. The equal operator `==` will not work!\n::::\n:::::\nCommands to exclude missing data (NA’s)\n:::\n\n### Modifying and transforming data {#sec-chap02-3-3}\n\nFor modifying data I will rouintely use the {**dpylr**} package. Here I will only list other options to remind me if I will see these functions.\n\n:::::{.my-bullet-list}\n:::{.my-bullet-list-header}\nModifying and transforming data without using {**dpylr**}\n:::\n::::{.my-bullet-list-container}\n\n- `base::transform()`: Create or modify several variables in a data frame at once.\n- `base::cut()`: creates bins for numeric variables. (For this function I didn't find an equivalent in the {**tidyverse**} ecosysystem.)\n- `car::Recode()`: same as `base::cut()` but mor flexible.\n\n::::\n:::::\n\n### Binding rows and columns (empty) {#sec-chap02-3-4}\n\n### Aggregating data frames (empty) {#sec-chap02-3-5}\n\n### Merging data frames (empty) {#sec-chap02-3-6}\n\n### Reshaping data (empty) {#sec-chap02-3-7}\n\n## Working with matrices, arrays, and lists (empty) {#sec-chap02-4}\n\n## Dates and times (empty) {#sec-chap02-5}\n\n## Character data (empty) {#sec-chap02-6}\n\n## Large datasets in R (empty) {#sec-chap02-7}\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}